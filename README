NAME
    Algorithm::FEC - Forward Error Correction using Vandermonde Matrices

SYNOPSIS
     use Algorithm::FEC;

DESCRIPTION
    This module is an interface to the fec library by Luigi Rizzo et al.,
    see the file README.fec in the distribution for more details.

    This library implements a simple ("encoded_packets","data_packets")
    erasure code based on Vandermonde matrices. The encoder takes
    "data_packets" packets of size "block_size" each, and is able to produce
    up to "encoded_packets" different encoded packets, numbered from 0 to
    "encoded_packets-1", such that any subset of "data_packets" members
    permits reconstruction of the original data.

    Allowed values for "data_packets" and "encoded_packets" must obey the
    following equation:

       data_packets <= encoded_packets <= MAXBLOCKS

    Where "MAXBLOCKS=256" for the fast implementation and "MAXBLOCKS=65536"
    for the slow implementation (the implementation is chosen
    automatically).

    $fec = new data_packets, encoded_packets, blocksize
    $fec->set_blocks ([array_of_blocks])
        Sets the data blocks used for the encoding. Each member of the array
        can either be:

        * a string of size "blocksize" "exactly".
            This is useful for small files (encoding entirely in memory).

        * a filehandle of a file of size "blocksize" "exactly".
            This is useful when the amount of data is large and resides in
            single files.

        * a reference to an array containing a filehandle and, optionally,
        an offset into that file.
            This is useful if the amount of data is large and resides in a
            single file. Needless to say, all parts must not overlap and
            must fit into the file.

        If your data is not of the required size (i.e. a multiple of
        "blocksize" bytes), then you must pad it (e.g. with zero bytes) on
        encoding, and truncate it after decoding.

        If called without arguments, the internal storage associated with
        the blocks is freed again.

    $block = $fec->encode (block_index)
        Creates a single encoded packet of index "block_index", which must
        be between 0 and "encoded_packets-1" (inclusive). The blocks from 0
        to "data_packets-1" are simply copies of the original data blocks.

        The encoded block is returned as a perl scalar (so the blocks should
        fit into memory. If this is a problem for you mail me and I'll make
        it a file.

    $fec->decode ([array_of_blocks], [array_of_indices])
        Decode "data_packets" of blocks (see "set_blocks" for the
        "array_of_blocks" parameter).

        Since these are not necessarily the original data blocks, an array
        of indices (ranging from 0 to "encoded_packets-1") must be supplied
        as the second arrayref.

        Both arrays must have exactly "data_packets" entries.

        After decoding, the blocks will be modified in place (if necessary),
        and the array of indices will be updates to reflect the changes: The
        n-th entry in the indices array is the index of the n-th data block
        of the file.

        That is, if you call this function with "indices = [4,3,1]", with
        "data_packets = 3", then this array will be returned: "[0,2,1]".
        This means that input block 0 corresponds file block 0, input block
        1 to file block 2 and input block 2 to data block 1.

        You can just iterate over this array and write out the corresponding
        data block (although this is inefficient).

        Only input blocks with indices >= "data_packets" will be modified,
        blocks that already contain the original data will just be
        reordered.

        This method destroys the block array as set up by "set_blocks".

    $fec->copy ($srcblock, $dstblock)
        Utility function that simply copies one block (specified like in
        "set_blocks") into another. This, btw., destroys the blocks set by
        "set_blocks".

        If you don't understand why this helps, feel free to ignore it :)

    COMPATIBILITY
        The way this module works is compatible with the way freenet
        (<http://freenet.sf.net>) encodes files. Comaptibility to other file
        formats or networks is not know, please tell me if you find more
        examples.

SEE ALSO
        Net::FCP. And the author, who might be happy to receive mail from
        any user, just to see that this rather rarely-used module is
        actually being used (except for freenet ;)

BUGS
         * largely untested, please change this.
         * file descriptors are not supported, but should be.
         * utility functions for files should be provided.
         * 16 bit version not tested

AUTHOR
         Marc Lehmann <pcg@goof.com>
         http://home.schmorp.de

